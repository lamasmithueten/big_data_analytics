% !TEX root =  master.tex
\chapter{Visualisieren der Daten (Phil Richter)}
Nach der Bereinigung und dem Speichern der Daten in einer Datenbank, wie in den vorherigen Kapiteln beschrieben, können die Daten visualisiert werden. Dafür wird als Grundlage
die Programmiersprache Python verwendet. Diese ist vorallem im Bereich der Datenanalyse und -visualisierung sehr weit verbreitet.

Für das Laden und Visualisiern der Daten werden folgende Packages verwendet:
\begin{table}[h!]
    \centering
    \begin{tabularx}{\textwidth}{|c|c|>{\centering\arraybackslash}X|}
        \hline
        \textbf{Package} & \textbf{Version} & \textbf{Beschreibung} \\ \hline
        dotenv & 1.0.1 & Lädt Umgebungsvariablen aus einer \textit{.env} Datei \\ \hline
        sqlalchemy & 2.0.36 & Ermöglicht Zugriff auf die Datenbank, sowie Datenbankabfragen \\ \hline
        pandas & 2.2.3 & Ermöglicht die Manipulation, Analyse und Verarbeitung von Daten \\ \hline
        matplotlib & 3.9.2 & Erstellt aus gegebenen Daten anpassbare Diagramme \\ \hline
        seaborn & 0.13.2 & Basiert auf \textit{matplotlib} und wird ebenfalls zur Datenvisualisierung verwendet \\ \hline
    \end{tabularx}
    \caption{Auflistung aller verwendeten Packages, sowie ihrer Versionen}
\end{table}

\section{Laden der Daten}
Im ersten Schritt der Visualisieren werden die Daten aus der Datenbank geladen. Dafür werden die Datenbankverbindungsinformationen mit Hilfe von \textit{dotenv}
aus einer lokal definierten \textit{.env} Datei geladen. Anschließend wird mit \textit{sqlalchemy} eine Verbindung zur Datenbank aufgebaut und die Daten werden 
mit einer SQL-Querry abgefragt. Die abgefrageten Daten werden in einem \textit{pandas} DataFrame gespeichert. Ein DataFrame ist dabei eine zweidimensionale Datenstruktur,
wie eine Tabelle. Im folgendem Python-Code werden die Daten wie beschrieben geladen:

\lstset{
	breaklines=true,         % Enable line wrapping
	breakatwhitespace=false, % Allow breaks at any character (not just whitespace)
	basicstyle=\ttfamily,    % Use monospaced font
}

\begin{lstlisting}[caption={\texttt{load data from the database}},captionpos=b]
    import os
    import re
    import numpy as np
    import pandas as pd
    import seaborn as sn
    import matplotlib.pyplot as plt
    from sqlalchemy import create_engine
    from dotenv import load_dotenv

    load_dotenv() # load environment variables

    # get the environment variables
    b_user = os.getenv("DB_USER")
    db_password = os.getenv("DB_PASSWORD")
    db_name = os.getenv("DB_NAME")
    db_host = os.getenv("DB_HOST")
    db_port = os.getenv("DB_PORT")

    db_url = f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}" # create the db url
    engine = create_engine(db_url)

    query = "SELECT * FROM intel;" # query to get the data from the database
    df = pd.read_sql(query, engine) # store the data in a dataframe
\end{lstlisting}

\section{Bereinigen der geladenen Daten}
Auch wenn die Daten, wie im Kapitel \ref{chap:säubern} beschrieben, bereits vor dem Speichern in die Datenbank bereinigt werden, bleinen kleine
Unreinheiten in den Daten bestehen. Daher werden bestimmte Spalten im DataFrame nochmals angepasst.

Ein Beispiel dafür ist die Spalte \textit{produktsortiment}. Diese enthält die jeweilige Generation des Prozessors, welche im Datensatz in drei verschiedenen
Schreibweisen vorkommt:
\begin{itemize}
    \item Die Generation als Zahl, z.B. \textit{4. Generation}
    \item Die Generation als Zahl ausgeschrieben, z.B. \textit{vierte Generation}
    \item Die Generation als englische Zahl, z.B. \textit{4th Generation}
\end{itemize}
Um die Prozessoren für die Visualisierung nach ihrer Generation Gruppieren/Sortieren zu können, wird die Spalte \textit{produktsortiment}
in eine neue Spalte \textit{generation} umgewandelt, wobei die Schreibweise vereinheitlicht wird. Dies wird mit Hilfe der Funktion \textit{extract\_generation}
gemacht. Der Code dazu sieht wie folgt aus:
\begin{lstlisting}[caption={\texttt{Funktion extraxct\_generation}},captionpos=b]
    number_words = {
        "erste": 1, "zweite": 2, "dritte": 3, "vierte": 4, "fuenfte": 5,
        "sechste": 6, "siebte": 7, "achte": 8, "neunte": 9, "zehnte": 10
    }

    def extract_generation(gen_text):
        match_numeric = re.search(r'(\d+)(?:\.|th)?\s?Gen', gen_text, re.IGNORECASE)
        if match_numeric:
            return int(match_numeric.group(1))
        for word, num in number_words.items():
            if word in gen_text.lower():
                return num
        return None

    df['generation'] = df['produktsortiment'].apply(extract_generation)
\end{lstlisting}